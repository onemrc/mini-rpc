# 异步通信的实现

## 概述

与序列化同样的思路，把通信的部分也封装成一个 `Transport` 接口。对于通信模块的需求是这样的：只需要客户端给服务端发送请求，然后服务返回响应就可以了。所以，我们的通信接口只需要提供一个发送请求方法就可以了。

## 核心接口设计

### Transport 接口

```java
public interface Transport {
    /**
     * 发送请求命令
     * @param request 请求命令
     * @return 返回值是一个Future，支持异步调用
     */
    CompletableFuture<Command> send(Command request);
}
```

使用 `CompletableFuture` 作为返回值，这样有比较高的灵活性：
- 可以直接调用它的 `get()` 方法来获取响应数据，这就相当于**同步调用**
- 也可以使用以 `then` 开头的一系列异步方法，指定当响应返回的时候，需要执行的操作，就等同于**异步调用**

## 数据结构设计

### Command 类

`Command` 类中封装了需要发送的请求数据：

```java
public class Command {
    protected Header header;    // 命令头
    private byte[] payload;     // 序列化之后的 payload 字节数组
    
    // 构造函数
    public Command(Header header, byte[] payload) {
        this.header = header;
        this.payload = payload;
    }
    
    // getter/setter 方法
    public Header getHeader() { return header; }
    public byte[] getPayload() { return payload; }
}
```

### Header 类

```java
public class Header {
    private int requestId;      // 请求ID
    private int version;        // 版本号
    private int type;           // 类型
    
    // 构造函数和getter/setter方法
    public Header(int requestId, int version, int type) {
        this.requestId = requestId;
        this.version = version;
        this.type = type;
    }
}
```

## 异步传输实现

### NettyTransport 实现

`Transport` 接口的实现类 `NettyTransport`：

```java
public class NettyTransport implements Transport {
    private final Channel channel;
    private final InFlightRequests inFlightRequests;
    
    @Override
    public CompletableFuture<Command> send(Command request) {
        // 构建返回值
        CompletableFuture<Command> completableFuture = new CompletableFuture<>();
        try {
            // 将在途请求放到inFlightRequests中
            inFlightRequests.put(new ResponseFuture(
                request.getHeader().getRequestId(), 
                completableFuture
            ));
            
            // 发送命令
            channel.writeAndFlush(request).addListener((ChannelFutureListener) channelFuture -> {
                // 处理发送失败的情况
                if (!channelFuture.isSuccess()) {
                    completableFuture.completeExceptionally(channelFuture.cause());
                    channel.close();
                }
            });
        } catch (Throwable t) {
            // 处理发送异常
            inFlightRequests.remove(request.getHeader().getRequestId());
            completableFuture.completeExceptionally(t);
        }
        return completableFuture;
    }
}
```

### 实现逻辑分析

实际上就干了两件事：

1. **管理在途请求**：把请求中的 `requestId` 和返回的 `completableFuture` 一起，构建了一个 `ResponseFuture` 对象，然后把这个对象放到了 `inFlightRequests` 这个变量中。`inFlightRequests` 中存放了所有在途的请求，也就是已经发出了请求但还没有收到响应的这些 `responseFuture` 对象。

2. **发送网络请求**：调用 netty 发送数据的方法，把这个 `request` 命令发给对方。

## 在途请求管理

### InFlightRequests 类

```java
public class InFlightRequests {
    private final Map<Integer, ResponseFuture> futureMap = new ConcurrentHashMap<>();
    private final Semaphore semaphore = new Semaphore(10); // 背压控制
    private final ScheduledExecutorService scheduledExecutorService = 
        Executors.newSingleThreadScheduledExecutor();
    private final ScheduledFuture<?> scheduledFuture;
    
    private static final int TIMEOUT_SEC = 10;
    
    public InFlightRequests() {
        // 启动定时任务，清理超时请求
        scheduledFuture = scheduledExecutorService.scheduleAtFixedRate(
            this::removeTimeoutFutures, 
            TIMEOUT_SEC, 
            TIMEOUT_SEC, 
            TimeUnit.SECONDS
        );
    }
    
    public void put(ResponseFuture responseFuture) {
        try {
            semaphore.acquire(); // 获取信号量，实现背压控制
            futureMap.put(responseFuture.getRequestId(), responseFuture);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException(e);
        }
    }
    
    public ResponseFuture remove(int requestId) {
        ResponseFuture future = futureMap.remove(requestId);
        if (future != null) {
            semaphore.release(); // 释放信号量
        }
        return future;
    }
    
    // 清理超时请求
    private void removeTimeoutFutures() {
        futureMap.entrySet().removeIf(entry -> {
            if (System.nanoTime() - entry.getValue().getTimestamp() > 
                TIMEOUT_SEC * 1000000000L) {
                semaphore.release();
                return true;
            } else {
                return false;
            }
        });
    }
}
```

## 异步网络传输的关键点

### 1. 背压机制

在实现异步网络传输的时候，一定要配套实现一个**背压的机制**，避免客户端请求速度过快，导致大量的请求失败。

`inFlightRequests` 这个变量中存储了所有已发送的请求，如果在网络请求发送时出现异常，那么这个变量里面记录的某些失败请求就永远得不到响应，也就是不会释放。这个变量占的内存就会越来越大，所以，这里需要捕获异常，把失败请求移除。

### 2. 超时处理机制

即使是我们对所有能捕获的异常都做了处理，也不能保证所有 `ResponseFuture` 都能正常或者异常结束，比如说，编写对端程序的程序员写的代码有问题，收到了请求就是没给我们返回响应，为了应对这种情况，还必须有一个兜底超时的机制来保证所有情况下 `ResponseFuture` 都能结束。

```java
// 存在超过特定时间，移除出去。
private void removeTimeoutFutures() {
    futureMap.entrySet().removeIf(entry -> {
        if (System.nanoTime() - entry.getValue().getTimestamp() > 
            TIMEOUT_SEC * 1000000000L) {
            semaphore.release();
            return true;
        } else {
            return false;
        }
    });
}
```

### 3. 信号量控制

使用 `Semaphore` 来控制并发请求数量，实现背压控制：

```java
private final Semaphore semaphore = new Semaphore(10); // 最多允许10个在途请求

public void put(ResponseFuture responseFuture) {
    try {
        semaphore.acquire(); // 获取信号量
        futureMap.put(responseFuture.getRequestId(), responseFuture);
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        throw new RuntimeException(e);
    }
}
```

## 请求响应处理

### ResponseInvocation 类

在 `ResponseInvocation` 这个类中异步接收所有服务端返回的响应，处理逻辑比较简单，就是根据响应头中的 `requestId`，去在途请求 `inFlightRequest` 中查找对应的 `ResponseFuture`，设置返回值并结束这个 `ResponseFuture` 就可以了。

```java
public class ResponseInvocation extends SimpleChannelInboundHandler<Command> {
    private final InFlightRequests inFlightRequests;
    
    @Override
    protected void channelRead0(ChannelHandlerContext ctx, Command response) {
        ResponseFuture future = inFlightRequests.remove(response.getHeader().getRequestId());
        if (future != null) {
            future.getCompletableFuture().complete(response);
        }
    }
}
```

## 使用示例

### 同步调用

```java
// 同步调用
Command response = transport.send(request).get();
```

### 异步调用

```java
// 异步调用
transport.send(request).thenAccept(response -> {
    // 处理响应
    System.out.println("收到响应: " + response);
}).exceptionally(throwable -> {
    // 处理异常
    System.err.println("请求失败: " + throwable.getMessage());
    return null;
});
```

## 技术优势

### 1. 高性能
- 基于Netty的NIO异步网络通信
- 非阻塞I/O操作

### 2. 可扩展性
- 支持大量并发连接
- 背压机制防止系统过载

### 3. 可靠性
- 超时机制保证请求不会无限等待
- 异常处理保证系统稳定性

### 4. 灵活性
- 支持同步和异步两种调用方式
- 易于集成到现有系统

## 总结

异步通信实现是RPC框架的核心技术之一，通过 `CompletableFuture` + `Netty` + 背压控制的组合，实现了高性能、高可靠性的网络通信。这种设计既保证了系统的吞吐量，又提供了良好的容错能力，是现代RPC框架的典型实现方式。
