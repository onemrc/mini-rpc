# 通用序列化实现

## 概述

一般的RPC框架都是采用主流通用的序列化实现，比如 gRPC 采用的是 Protobuf 序列化实现，Dubbo 支持 hession2 等好几种序列化实现。

其实核心原理都差不多，本项目中实现了一个通用的序列化接口，支持多种序列化协议的插拔式使用。

## 设计目标

### 1. 通用性
- 支持任意Java对象的序列化和反序列化
- 统一的序列化接口，屏蔽底层实现差异

### 2. 可扩展性
- 基于SPI机制支持多种序列化实现
- 易于添加新的序列化协议

### 3. 类型安全
- 编译时类型检查
- 运行时类型验证

## 核心接口设计

### Serializer 接口

为了解耦，这里定义一个 `Serializer` 接口，所有的序列化实现类都实现这个接口：

```java
public interface Serializer<T> {
    /**
     * 计算对象序列化后的长度，主要用于申请存放序列化数据的字节数组
     * @param entry 待序列化的对象
     * @return 对象序列化后的长度
     */
    int size(T entry);

    /**
     * 序列化对象。将给定的对象序列化成字节数组
     * @param entry 待序列化的对象
     * @param bytes 存放序列化数据的字节数组
     * @param offset 数组的偏移量，从这个位置开始写入序列化数据
     * @param length 对象序列化后的长度，也就是{@link Serializer#size(java.lang.Object)}方法的返回值。
     */
    void serialize(T entry, byte[] bytes, int offset, int length);

    /**
     * 反序列化对象
     * @param bytes 存放序列化数据的字节数组
     * @param offset 数组的偏移量，从这个位置开始写入序列化数据
     * @param length 对象序列化后的长度
     * @return 反序列化之后生成的对象
     */
    T parse(byte[] bytes, int offset, int length);

    /**
     * 用一个字节标识对象类型，每种类型的数据应该具有不同的类型值
     */
    byte type();

    /**
     * 返回序列化对象类型的Class对象。
     * 目的是，在执行序列化的时候，能通过被序列化的对象类型找到对应序列化实现类。
     */
    Class<T> getSerializeClass();
}
```

## 通用序列化支持类

### SerializeSupport 设计

使用一个静态类来实现序列化的通用功能：

```java
public class SerializeSupport {
    
    // 反序列化
    public static <E> E parse(byte[] buffer) {
        // ...
    }
    
    // 序列化
    public static <E> byte[] serialize(E entry) {
        // ...
    }
}
```

### 使用示例

这样我们可以直接使用：

```java
// 序列化
MyClass myClassObject = new MyClass();
byte[] bytes = SerializeSupport.serialize(myClassObject);

// 反序列化
MyClass myClassObject1 = SerializeSupport.parse(bytes);
```

## 实现原理

### 1. 类型映射机制

利用这个 `Serializer` 接口，我们就可以来实现 `SerializeSupport` 这个支持任何对象类型序列化的通用静态类。

用了两个Map来存放所有实现 `Serializer` 接口的实现类：

```java
// key: 序列化对象类型 , value : 序列化实现
private static Map<Class<?>, Serializer<?>> serializerMap = new HashMap<>();

// key : 序列化实现类型 , value : 序列化对象类型
private static Map<Byte, Class<?>> typeMap = new HashMap<>();
```

### 2. SPI机制加载

为了可以在初始化的时候，所有的 `Serializer` 实现类加载到这两个Map中。这里利用Java中的SPI类加载机制。

#### SPI配置文件

在 `META-INF/services/` 目录下创建配置文件：

```
# META-INF/services/com.github.onemrc.rpc.serialize.Serializer
com.github.onemrc.rpc.serialize.impl.StringSerializer
com.github.onemrc.rpc.serialize.impl.RpcRequestSerializer
com.github.onemrc.rpc.serialize.impl.MetadataSerializer
```

#### 初始化代码

```java
static {
    // 通过SPI加载所有Serializer实现
    ServiceLoader<Serializer> serviceLoader = ServiceLoader.load(Serializer.class);
    for (Serializer serializer : serviceLoader) {
        register(serializer);
    }
}

private static void register(Serializer serializer) {
    serializerMap.put(serializer.getSerializeClass(), serializer);
    typeMap.put(serializer.type(), serializer.getSerializeClass());
}
```

## 具体实现示例

### StringSerializer 实现

```java
public class StringSerializer implements Serializer<String> {
    @Override
    public int size(String entry) {
        return entry.getBytes(StandardCharsets.UTF_8).length;
    }

    @Override
    public void serialize(String entry, byte[] bytes, int offset, int length) {
        byte[] strBytes = entry.getBytes(StandardCharsets.UTF_8);
        System.arraycopy(strBytes, 0, bytes, offset, strBytes.length);
    }

    @Override
    public String parse(byte[] bytes, int offset, int length) {
        return new String(bytes, offset, length, StandardCharsets.UTF_8);
    }

    @Override
    public byte type() {
        return Types.TYPE_STRING;
    }

    @Override
    public Class<String> getSerializeClass() {
        return String.class;
    }
}
```

### RpcRequestSerializer 实现

```java
public class RpcRequestSerializer implements Serializer<RpcRequest> {
    @Override
    public int size(RpcRequest entry) {
        return Integer.BYTES + entry.getInterfaceName().getBytes().length +
               Integer.BYTES + entry.getMethodName().getBytes().length +
               Integer.BYTES + entry.getSerializedArguments().length;
    }

    @Override
    public void serialize(RpcRequest entry, byte[] bytes, int offset, int length) {
        int pos = offset;
        
        // 序列化接口名
        byte[] interfaceNameBytes = entry.getInterfaceName().getBytes();
        System.arraycopy(intToBytes(interfaceNameBytes.length), 0, bytes, pos, Integer.BYTES);
        pos += Integer.BYTES;
        System.arraycopy(interfaceNameBytes, 0, bytes, pos, interfaceNameBytes.length);
        pos += interfaceNameBytes.length;
        
        // 序列化方法名
        byte[] methodNameBytes = entry.getMethodName().getBytes();
        System.arraycopy(intToBytes(methodNameBytes.length), 0, bytes, pos, Integer.BYTES);
        pos += Integer.BYTES;
        System.arraycopy(methodNameBytes, 0, bytes, pos, methodNameBytes.length);
        pos += methodNameBytes.length;
        
        // 序列化参数
        byte[] argsBytes = entry.getSerializedArguments();
        System.arraycopy(intToBytes(argsBytes.length), 0, bytes, pos, Integer.BYTES);
        pos += Integer.BYTES;
        System.arraycopy(argsBytes, 0, bytes, pos, argsBytes.length);
    }

    @Override
    public RpcRequest parse(byte[] bytes, int offset, int length) {
        int pos = offset;
        
        // 反序列化接口名
        int interfaceNameLength = bytesToInt(bytes, pos);
        pos += Integer.BYTES;
        String interfaceName = new String(bytes, pos, interfaceNameLength);
        pos += interfaceNameLength;
        
        // 反序列化方法名
        int methodNameLength = bytesToInt(bytes, pos);
        pos += Integer.BYTES;
        String methodName = new String(bytes, pos, methodNameLength);
        pos += methodNameLength;
        
        // 反序列化参数
        int argsLength = bytesToInt(bytes, pos);
        pos += Integer.BYTES;
        byte[] argsBytes = new byte[argsLength];
        System.arraycopy(bytes, pos, argsBytes, 0, argsLength);
        
        return new RpcRequest(interfaceName, methodName, argsBytes);
    }

    @Override
    public byte type() {
        return Types.TYPE_RPC_REQUEST;
    }

    @Override
    public Class<RpcRequest> getSerializeClass() {
        return RpcRequest.class;
    }
}
```

## 类型定义

```java
public class Types {
    public static final byte TYPE_STRING = 0;
    public static final byte TYPE_RPC_REQUEST = 1;
    public static final byte TYPE_METADATA = 2;
    // 可以继续添加更多类型
}
```

## 使用流程

### 1. 序列化流程

```java
public static <E> byte[] serialize(E entry) {
    // 1. 获取对象类型
    Class<?> clazz = entry.getClass();
    
    // 2. 查找对应的序列化器
    Serializer serializer = serializerMap.get(clazz);
    if (serializer == null) {
        throw new SerializeException("找不到序列化器: " + clazz.getName());
    }
    
    // 3. 计算序列化后的大小
    int size = serializer.size(entry);
    
    // 4. 创建字节数组（类型标识 + 数据）
    byte[] bytes = new byte[1 + size];
    bytes[0] = serializer.type();
    
    // 5. 执行序列化
    serializer.serialize(entry, bytes, 1, size);
    
    return bytes;
}
```

### 2. 反序列化流程

```java
public static <E> E parse(byte[] buffer) {
    // 1. 获取类型标识
    byte type = buffer[0];
    
    // 2. 根据类型查找对应的Class
    Class<?> clazz = typeMap.get(type);
    if (clazz == null) {
        throw new SerializeException("找不到类型: " + type);
    }
    
    // 3. 查找对应的序列化器
    Serializer serializer = serializerMap.get(clazz);
    if (serializer == null) {
        throw new SerializeException("找不到序列化器: " + clazz.getName());
    }
    
    // 4. 执行反序列化
    return (E) serializer.parse(buffer, 1, buffer.length - 1);
}
```

## 技术优势

### 1. 可扩展性
- 基于SPI机制，易于添加新的序列化协议
- 支持多种序列化算法并存

### 2. 类型安全
- 编译时类型检查
- 运行时类型验证

### 3. 性能优化
- 预计算序列化大小，避免多次内存分配
- 直接操作字节数组，减少对象创建

### 4. 内存效率
- 紧凑的二进制格式
- 最小化序列化开销

## 总结

通用序列化实现是RPC框架的重要基础设施，通过接口抽象 + SPI机制的设计，实现了序列化协议的插拔式使用。这种设计既保证了系统的灵活性，又提供了良好的性能表现，是现代RPC框架的典型实现方式。
