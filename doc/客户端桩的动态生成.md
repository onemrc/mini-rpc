# 客户端"桩"的动态生成

## 概述

"桩"是RPC框架在客户端的服务代理，它和远程服务实现了相同的接口。客户端在调用RPC框架提供的服务时，实际调用的是"桩"提供的方法。"桩"具体实现的方法中，会发送请求到服务端获取结果并返回给调用方。

## 设计模式：代理模式

这是采用了设计模式中的**代理模式**，代理模式给某个对象提供一个代理对象，并由代理对象控制对原对象的引用，被代理的对象成为委托对象。

日常的开发中，代理模式一般是用来在调用链中动态地注入一些非侵入的业务逻辑。

## 核心接口设计

### StubFactory 接口

项目中RPC框架的客户端代理类的实现通过 `StubFactory` 接口：

```java
public interface StubFactory {
    /**
     * 创建一个桩的对象实例
     * @param transport 网络传输对象
     * @param serviceClass 服务接口类
     * @param <T> 服务接口类型
     * @return 桩的实例
     */
    <T> T createStub(Transport transport, Class<T> serviceClass);
}
```

- `Transport` 是给服务端发请求时用的
- `serviceClass` 用来指定桩的创建类型

## 动态生成策略

### 问题分析

因为桩的对象实例是未知的，一直在变的，这个桩它是一个由 RPC 框架生成的类，这个类它要实现给定的接口，里面的逻辑就是把方法名和参数封装成请求，发送给服务端，然后再把服务端返回的调用结果返回给调用方。

所以核心问题就是如何来生成这个类。

### 解决方案：动态编译

这里采用了一个轻量级通用的做法：

1. **生成桩的源代码**
2. **动态地编译这个生成的源代码**
3. **加载到 JVM 中**

### 抽象基类设计

由于动态生成的桩，它每个方法的逻辑都是一样的，都是把类名、方法名和方法的参数封装成请求，然后发给服务端，收到服务端响应之后再把结果作为返回值，返回给调用方。

所以我们定义一个 `AbstractStub` 的抽象类，在这个类中实现大部分通用的逻辑，让所有动态生成的桩都继承这个抽象类，这样动态生成桩的代码会更少一些。

## 具体实现

### DynamicStubFactory 实现

```java
public class DynamicStubFactory implements StubFactory {
    private final static String STUB_SOURCE_TEMPLATE =
            "package com.github.rpc.client.stubs;\n" +
            "import com.github.rpc.serialize.SerializeSupport;\n" +
            "\n" +
            "public class %s extends AbstractStub implements %s {\n" +
            "    @Override\n" +
            "    public String %s(String arg) {\n" +
            "        return SerializeSupport.parse(\n" +
            "                invokeRemote(\n" +
            "                        new RpcRequest(\n" +
            "                                \"%s\",\n" +
            "                                \"%s\",\n" +
            "                                SerializeSupport.serialize(arg)\n" +
            "                        )\n" +
            "                )\n" +
            "        );\n" +
            "    }\n" +
            "}";

    @Override
    @SuppressWarnings("unchecked")
    public <T> T createStub(Transport transport, Class<T> serviceClass) {
        try {
            // 1. 填充模板
            String stubSimpleName = serviceClass.getSimpleName() + "Stub";
            String classFullName = serviceClass.getName();
            String stubFullName = "com.github.rpc.client.stubs." + stubSimpleName;
            String methodName = serviceClass.getMethods()[0].getName();

            String source = String.format(STUB_SOURCE_TEMPLATE, 
                stubSimpleName, classFullName, methodName, classFullName, methodName);
            
            // 2. 编译源代码
            JavaStringCompiler compiler = new JavaStringCompiler();
            Map<String, byte[]> results = compiler.compile(stubSimpleName + ".java", source);
            
            // 3. 加载编译好的类
            Class<?> clazz = compiler.loadClass(stubFullName, results);

            // 4. 创建桩实例并设置Transport
            ServiceStub stubInstance = (ServiceStub) clazz.newInstance();
            stubInstance.setTransport(transport);
            
            // 5. 返回这个桩
            return (T) stubInstance;
        } catch (Throwable t) {
            throw new RuntimeException(t);
        }
    }
}
```

## 实现步骤详解

### 1. 模板填充
- 根据服务接口类名生成桩类名（如：`HelloService` → `HelloServiceStub`）
- 获取服务接口的完整类名和方法名
- 使用 `String.format()` 填充代码模板

### 2. 动态编译
- 使用 `JavaStringCompiler` 将生成的源代码编译成字节码
- 编译结果存储在 `Map<String, byte[]>` 中

### 3. 类加载
- 使用 `compiler.loadClass()` 将编译好的字节码加载到JVM中
- 获得桩类的 `Class` 对象

### 4. 实例化
- 通过反射创建桩的实例
- 将 `Transport` 对象赋值给桩，使其能够与服务端通信

## 生成的桩类示例

以 `HelloService` 为例，生成的桩类代码大致如下：

```java
package com.github.rpc.client.stubs;

import com.github.rpc.serialize.SerializeSupport;

public class HelloServiceStub extends AbstractStub implements HelloService {
    @Override
    public String hello(String arg) {
        return SerializeSupport.parse(
                invokeRemote(
                        new RpcRequest(
                                "com.github.onemrc.rpc.hello.HelloService",
                                "hello",
                                SerializeSupport.serialize(arg)
                        )
                )
        );
    }
}
```

## 技术优势

### 1. 灵活性
- 支持任意接口的动态代理生成
- 无需预定义代理类

### 2. 性能
- 生成的代码直接调用，无反射开销
- 编译时优化

### 3. 类型安全
- 编译时类型检查
- 接口约束保证

### 4. 可维护性
- 代码模板集中管理
- 易于扩展和修改

## 注意事项

### 1. 类加载器
- 确保生成的类能够被正确加载
- 注意类加载器的隔离问题

### 2. 内存管理
- 动态生成的类会占用永久代/元空间内存
- 需要考虑类的卸载机制

### 3. 异常处理
- 编译失败时的异常处理
- 类加载失败时的降级策略

## 总结

动态桩生成是RPC框架的核心技术之一，通过代码模板 + 动态编译的方式，实现了对任意服务接口的透明代理。这种设计既保证了性能，又提供了足够的灵活性，是现代RPC框架的典型实现方式。
